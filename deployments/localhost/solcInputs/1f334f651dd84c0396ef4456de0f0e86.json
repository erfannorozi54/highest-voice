{
  "language": "Solidity",
  "sources": {
    "contracts/HighestVoice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title HighestVoice\n * @notice Permissionless, second-price sealed-bid auction for projecting the loudest voice on-chain.\n *         Each auction round lasts 24h: 12h commit, 12h reveal. Winner's post is projected for 24h.\n *         No owner/admin, ETH only, fully decentralized.\n */\ncontract HighestVoice {\n    // =============== EVENTS ===============\n    event NewCommit(address indexed bidder, uint256 auctionId);\n    event NewReveal(address indexed bidder, uint256 auctionId, uint256 bid);\n    event NewWinner(address indexed winner, uint256 auctionId, uint256 amount, string text, string imageCid, string voiceCid);\n    event Refund(address indexed bidder, uint256 auctionId, uint256 amount);\n\n    // =============== STRUCTS ===============\n    struct Post {\n        address owner;\n        string text; // ≤100 words\n        string imageCid; // ≤500kB\n        string voiceCid; // ≤1MB, ≤60s\n    }\n    struct BidCommit {\n        bytes32 commitHash;\n        uint256 collateral;\n        bool revealed;\n        uint256 revealedBid;\n        string text;\n        string imageCid;\n        string voiceCid;\n    }\n    struct Auction {\n        uint256 startTime;\n        uint256 commitEnd;\n        uint256 revealEnd;\n        bool settled;\n        address[] bidders;\n        mapping(address => BidCommit) commits;\n        address winner;\n        uint256 winningBid;\n        uint256 secondBid;\n        Post winnerPost;\n    }\n\n    // =============== CONSTANTS ===============\n    uint256 public constant COMMIT_DURATION = 12 hours;\n    uint256 public constant REVEAL_DURATION = 12 hours;\n    uint256 public constant WORD_LIMIT = 100;\n    uint256 public constant IMAGE_CID_LIMIT = 500 * 1024; // bytes\n    uint256 public constant VOICE_CID_LIMIT = 1024 * 1024; // bytes\n    uint256 public constant VOICE_SECONDS_LIMIT = 60; // metadata only\n\n    // =============== STATE ===============\n    uint256 public currentAuctionId;\n    mapping(uint256 => Auction) private auctions;\n    Post public lastWinnerPost;\n    uint256 public lastWinnerTime;\n\n    // =============== REENTRANCY ===============\n    uint256 private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, \"ReentrancyGuard: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    // =============== MODIFIERS ===============\n    modifier onlyDuringCommit(uint256 auctionId) {\n        Auction storage auction = auctions[auctionId];\n        require(block.timestamp >= auction.startTime && block.timestamp < auction.commitEnd, \"Not in commit phase\");\n        _;\n    }\n    modifier onlyDuringReveal(uint256 auctionId) {\n        Auction storage auction = auctions[auctionId];\n        require(block.timestamp >= auction.commitEnd && block.timestamp < auction.revealEnd, \"Not in reveal phase\");\n        _;\n    }\n    modifier onlyAfterReveal(uint256 auctionId) {\n        Auction storage auction = auctions[auctionId];\n        require(block.timestamp >= auction.revealEnd, \"Reveal not ended\");\n        _;\n    }\n\n    // =============== CONSTRUCTOR ===============\n    constructor() {\n        _startNewAuction();\n    }\n\n    // =============== VIEW FUNCTIONS ===============\n    function getCountdownEnd() external view returns (uint256) {\n        return auctions[currentAuctionId].revealEnd;\n    }\n\n    // =============== AUCTION LOGIC ===============\n    function commitBid(bytes32 commitHash) external payable onlyDuringCommit(currentAuctionId) lock {\n        Auction storage auction = auctions[currentAuctionId];\n        require(auction.commits[msg.sender].commitHash == bytes32(0), \"Already committed\");\n        require(msg.value > 0, \"Collateral required\");\n        auction.bidders.push(msg.sender);\n        auction.commits[msg.sender] = BidCommit({commitHash: commitHash, collateral: msg.value, revealed: false, revealedBid: 0, text: \"\", imageCid: \"\", voiceCid: \"\"});\n        emit NewCommit(msg.sender, currentAuctionId);\n    }\n    function revealBid(uint256 bidAmount, string calldata text, string calldata imageCid, string calldata voiceCid, bytes32 salt) external onlyDuringReveal(currentAuctionId) lock {\n        Auction storage auction = auctions[currentAuctionId];\n        BidCommit storage commit = auction.commits[msg.sender];\n        require(commit.commitHash != bytes32(0), \"No commit\");\n        require(!commit.revealed, \"Already revealed\");\n        require(commit.commitHash == keccak256(abi.encodePacked(bidAmount, text, imageCid, voiceCid, salt)), \"Invalid reveal\");\n        require(bidAmount <= commit.collateral, \"Insufficient collateral\");\n        require(_wordCount(text) <= WORD_LIMIT, \"Text too long\");\n        require(bytes(imageCid).length <= IMAGE_CID_LIMIT, \"Image CID too large\");\n        require(bytes(voiceCid).length <= VOICE_CID_LIMIT, \"Voice CID too large\");\n        // Voice duration check is off-chain, enforced by front-end/metadata\n        commit.revealed = true;\n        commit.revealedBid = bidAmount;\n        commit.text = text;\n        commit.imageCid = imageCid;\n        commit.voiceCid = voiceCid;\n        emit NewReveal(msg.sender, currentAuctionId, bidAmount);\n    }\n    /**\n     * @notice Increase collateral and/or update commitment during commit phase.\n     *         Allows a bidder to raise their bid by topping up collateral and updating the commit hash.\n     */\n    function raiseCommit(bytes32 newCommitHash) external payable onlyDuringCommit(currentAuctionId) lock {\n        Auction storage auction = auctions[currentAuctionId];\n        BidCommit storage commit = auction.commits[msg.sender];\n        require(commit.commitHash != bytes32(0), \"No commit\");\n        require(!commit.revealed, \"Already revealed\");\n        require(newCommitHash != bytes32(0), \"Invalid hash\");\n        if (msg.value > 0) {\n            commit.collateral += msg.value;\n        }\n        commit.commitHash = newCommitHash;\n    }\n    function settleAuction() external onlyAfterReveal(currentAuctionId) lock {\n        Auction storage auction = auctions[currentAuctionId];\n        require(!auction.settled, \"Already settled\");\n        uint256 highest = 0;\n        uint256 second = 0;\n        address winner = address(0);\n        // removed unused local variables for post data\n        // Find highest and second-highest revealed bids\n        for (uint256 i = 0; i < auction.bidders.length; i++) {\n            address bidder = auction.bidders[i];\n            BidCommit storage commit = auction.commits[bidder];\n            if (commit.revealed && commit.revealedBid > highest) {\n                second = highest;\n                highest = commit.revealedBid;\n                winner = bidder;\n            } else if (commit.revealed && commit.revealedBid > second) {\n                second = commit.revealedBid;\n            }\n        }\n        require(winner != address(0), \"No valid bids\");\n        // Save winner's post\n        BidCommit storage winCommit = auction.commits[winner];\n        auction.winner = winner;\n        auction.winningBid = highest;\n        auction.secondBid = second;\n        auction.settled = true;\n        auction.winnerPost = Post({owner: winner, text: winCommit.text, imageCid: winCommit.imageCid, voiceCid: winCommit.voiceCid});\n        lastWinnerPost = auction.winnerPost;\n        lastWinnerTime = block.timestamp;\n        // Refunds and payments\n        for (uint256 i = 0; i < auction.bidders.length; i++) {\n            address bidder = auction.bidders[i];\n            BidCommit storage commit = auction.commits[bidder];\n            uint256 refund = 0;\n            if (bidder == winner) {\n                // Winner pays second-highest bid\n                refund = commit.collateral > second ? commit.collateral - second : 0;\n                if (refund > 0) {\n                    (bool sent,) = bidder.call{value: refund}(\"\");\n                    require(sent, \"Refund failed\");\n                }\n            } else if (commit.revealed) {\n                // All other revealed bidders get full refund\n                refund = commit.collateral;\n                if (refund > 0) {\n                    (bool sent,) = bidder.call{value: refund}(\"\");\n                    require(sent, \"Refund failed\");\n                }\n            } else {\n                // Not revealed: collateral is forfeited\n            }\n            emit Refund(bidder, currentAuctionId, refund);\n        }\n        emit NewWinner(winner, currentAuctionId, highest, winCommit.text, winCommit.imageCid, winCommit.voiceCid);\n        _startNewAuction();\n    }\n    function _startNewAuction() internal {\n        currentAuctionId++;\n        Auction storage auction = auctions[currentAuctionId];\n        auction.startTime = block.timestamp;\n        auction.commitEnd = block.timestamp + COMMIT_DURATION;\n        auction.revealEnd = auction.commitEnd + REVEAL_DURATION;\n        auction.settled = false;\n    }\n    // =============== VIEW FUNCTIONS ===============\n    function getAuctionTimes(uint256 auctionId) external view returns (uint256 start, uint256 commitEnd, uint256 revealEnd) {\n        Auction storage auction = auctions[auctionId];\n        return (auction.startTime, auction.commitEnd, auction.revealEnd);\n    }\n    function getWinnerPost() external view returns (address owner, string memory text, string memory imageCid, string memory voiceCid, uint256 projectedUntil) {\n        return (lastWinnerPost.owner, lastWinnerPost.text, lastWinnerPost.imageCid, lastWinnerPost.voiceCid, lastWinnerTime + 24 hours);\n    }\n    function getAuctionResult(uint256 auctionId) external view returns (bool settled, address winner, uint256 winningBid, uint256 secondBid) {\n        Auction storage a = auctions[auctionId];\n        return (a.settled, a.winner, a.winningBid, a.secondBid);\n    }\n    function getMyBid(uint256 auctionId)\n        external\n        view\n        returns (\n            bytes32 commitHash,\n            uint256 collateral,\n            bool revealed,\n            uint256 revealedBid,\n            string memory text,\n            string memory imageCid,\n            string memory voiceCid\n        )\n    {\n        BidCommit storage c = auctions[auctionId].commits[msg.sender];\n        return (c.commitHash, c.collateral, c.revealed, c.revealedBid, c.text, c.imageCid, c.voiceCid);\n    }\n    // =============== UTILITY ===============\n    function _wordCount(string memory str) internal pure returns (uint256 count) {\n        bytes memory b = bytes(str);\n        bool inWord = false;\n        for (uint256 i = 0; i < b.length; i++) {\n            if (b[i] != 0x20 && b[i] != 0x0A && b[i] != 0x09) {\n                if (!inWord) {\n                    count++;\n                    inWord = true;\n                }\n            } else {\n                inWord = false;\n            }\n        }\n    }\n    receive() external payable { revert(\"Use commitBid\"); }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}